<!DOCTYPE html>
<html>
  <head>
    <title>Verifiable Barcodes v0.7</title>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
    <!--
      === NOTA BENE ===
      For the three scripts below, if your spec resides on dev.w3 you can check them
      out in the same tree and use relative links so that they'll work offline,
     -->
    <script src="//www.w3.org/Tools/respec/respec-w3c" class="remove"></script>
    <script class="remove" src="https://w3c.github.io/vc-data-model/common.js"></script>

    <script type="text/javascript" class="remove">
      var respecConfig = {
        subtitle: "Securing legacy barcodes using Verifiable Credentials",
        // specification status (e.g. WD, LCWD, NOTE, etc.). If in doubt use ED.
        group: "credentials",
        specStatus: "CG-DRAFT",

        // the specification's short name, as in http://www.w3.org/TR/short-name/
        shortName: "verifiable-barcodes",

        // if you wish the publication date to be other than today, set this
        //publishDate:  "",

        // if there is a previously published draft, uncomment this and set its YYYY-MM-DD date
        // and its maturity status
        // previousPublishDate:  "1977-03-15",
        // previousMaturity:  "WD",

        // if there a publicly available Editor's Draft, this is the link
        edDraftURI: "https://digitalbazaar.github.io/verifiable-barcodes/",
        //latestVersion: "",

        // if this is a LCWD, uncomment and set the end of its review period
        //implementationReportURI: "",
        //crEnd: "2024-01-17",

        // if you want to have extra CSS, append them to this list
        // it is recommended that the respec.css stylesheet be kept
        //extraCSS:             ["spec.css", "prettify.css"],

        // editors, add as many as you like
        // only "name" is required
        editors: [{
          name: "Manu Sporny",
          url: "https://www.linkedin.com/in/manusporny/",
          company: "Digital Bazaar",
          companyURL: "https://digitalbazaar.com/",
          w3cid: 41758
        }],

        // authors, add as many as you like.
        // This is optional, uncomment if you have authors as well as editors.
        // only "name" is required. Same format as editors.

        authors: [{
          name: "Manu Sporny", url: "https://www.linkedin.com/in/manusporny/",
          company: "Digital Bazaar", companyURL: "https://digitalbazaar.com/",
          w3cid: 41758
        }, {
          name: "Dave Longley", url: "https://github.com/dlongley",
          company: "Digital Bazaar", companyURL: "https://digitalbazaar.com/",
          w3cid: 48025
        }, {
          name: "Wesley Smith", url: "https://www.linkedin.com/in/wesley-smith-phd-24973a12b/",
          company: "Digital Bazaar", companyURL: "https://digitalbazaar.com/"
        }],

        // name of the WG
        //wg:           "W3C Credentials Community Group",

        // URI of the public WG page
        //wgURI:        "https://www.w3.org/community/credentials/",

        // name (with the @w3c.org) of the public mailing to which comments are due
        //wgPublicList: "public-credentials",

        github: "https://github.com/digitalbazaar/verifiable-barcodes/",

        otherLinks: [],

        // URI of the patent status for this WG, for Rec-track documents
        // !!!! IMPORTANT !!!!
        // This is important for Rec-track documents, do not copy a patent URI from a random
        // document unless you know what you're doing. If in doubt ask your friendly neighbourhood
        // Team Contact.
        // wgPatentURI:  "",
        maxTocLevel: 3,
        /*preProcess: [ webpayments.preProcess ],
        alternateFormats: [ {uri: "diff-20111214.html", label: "diff to previous version"} ],
        */
        localBiblio: {
          "CBOR-LD": {
            title: "Compact Binary Object Representation for Linked Data v0.7",
            href: "https://json-ld.github.io/cbor-ld-spec/"
          },
          "ICAO9303-3": {
            title: "Machine Readable Travel Documents Part 3: Specifications Common to all MRTDs, Eighth Edition, 2021",
            date: "2021",
            href: "https://www.icao.int/publications/Documents/9303_p3_cons_en.pdf",
            authors: [
              "ICAO"
            ],
            publisher: "International Civil Aviation Organization"
          },
          "ISO15438-2015": {
            title: "ISO/IEC 15438:2015: PDF417 Bar Code Symbology Specification",
            date: "2015",
            href: "https://www.iso.org/standard/65502.html",
            authors: [
              "ISO/IEC JTC 1/SC 31"
            ],
            publisher: "International Standards Organization"
          },
          "aamva-dl-id-card-design-standard": {
            title: "AAMVA DL/ID Card Design Standard (2020)",
            date: "2020",
            href: "https://www.aamva.org/assets/best-practices,-guides,-standards,-manuals,-whitepapers/aamva-dl-id-card-design-standard-(2020)",
            publisher: "American Association of Motor Vehicle Administrators"
          }
        },
        lint: {"no-unused-dfns": false},
        xref: ["INFRA"],
        postProcess: [restrictRefs],
        otherLinks: [{
          key: "Related Specifications",
          data: [{
            value: "The Verifiable Credentials Data Model v2.0",
            href: "https://www.w3.org/TR/vc-data-model-2.0/"
          }, {
            value: "Verifiable Credential Data Integrity v1.0",
            href: "https://www.w3.org/TR/vc-data-integrity/"
          }, {
            value: "The Elliptic Curve Digital Signature Algorithm Cryptosuites v1.0",
            href: "https://www.w3.org/TR/vc-di-ecdsa/"
          }, {
            value: "Compact Binary Object Representation for Linked Data v0.7",
            href: "https://json-ld.github.io/cbor-ld-spec/"
          }]
        }]
      };
    </script>
    <style>
code {
  color: rgb(199, 73, 0);
  font-weight: bold;
}
pre.nohighlight {
  overflow-x: auto;
  white-space: pre-wrap;
}
pre .highlight {
  font-weight: bold;
  color: green;
}
pre .comment {
  font-weight: bold;
  color: Gray;
}
.color-text {
  font-weight: bold;
  text-shadow: -1px 0 black, 0 1px black, 1px 0 black, 0 -1px black;
}
ol.algorithm {
  counter-reset: numsection;
  list-style-type: none;
}
ol.algorithm li {
  margin: 0.5em 0;
}
ol.algorithm li:before {
  font-weight: bold;
  counter-increment: numsection;
  content: counters(numsection, ".") ") ";
}
    </style>
  </head>
  <body>
    <section id="abstract">
      <p>
This specification describes a mechanism to protect legacy optical barcodes,
such as those found on driver's licenses (PDF417) and travel documents (MRZ),
using Verifiable Credentials [[VC-DATA-MODEL-2.0]]. The Verifiable Credential
representations are compact enough such that they fit in under 150 bytes and
can thus be integrated with traditional two-dimensional barcodes that are
printed on physical cards using legacy printing processes.
      </p>
    </section>

    <section id="sotd">

      <p>
This specification is experimental.
      </p>

    </section>

    <section>
      <h2>Introduction</h2>
      <p>
Legacy documentation, such as driver's licenses, passports, and travel
credentials often include machine-readable data that can be used to quickly read
the information from the document. This information is encoded in formats such
as PDF417 [[ISO15438-2015]], machine-readable zone (MRZ) [[ICAO9303-3]], and
other optically scannable codes that are formatted in one-dimensional or
two-dimensional "bars"; thus the term "barcode". This information is often
not protected from tampering and the readily available barcode generation and
scanning libraries mean that it is fairly trivial for anyone to generate these
barcodes.
      </p>
      <p>
It is, therefore, useful for an <a>issuer</a> of these barcodes to protect
the information contained within the barcode as well as the entity that
generated the barcode.
      </p>
      <p>
The [[[VC-DATA-MODEL-2.0]]] specification provides a global standard for
expressing credential information, such as those in a driver's license or
travel document. The [[[VC-DATA-INTEGRITY]]] specification provides a global
standard for securing credential information. These two specifications, when
combined, provide a means of protecting credentials from tampering,
expressing authorship of the credential, and providing the current status of
a credential in a privacy-protecting manner. These data formats, however, tend
to be too large to express in an optical barcode.
      </p>
      <p>
The [[[CBOR-LD]]] specification provides a means of compressing secured
<a>verifiable credentials</a> to the point at which it becomes feasible to
express the information as an optical barcode, or embedded within an optical
barcode.
      </p>
      <p>
This specification describes a mechanism to protect legacy optical barcodes,
such as those found on driver's licenses (PDF417) and travel documents (MRZ),
by using a <a>verifiable credential</a> [[VC-DATA-MODEL-2.0]] to express
information about the barcode, which is then secured using Data Integrity
[[VC-DATA-INTEGRITY]], and then compressed using CBOR-LD [[CBOR-LD]]. The
resulting <a>verifiable credential</a> representations are compact enough such
that they fit in under 140 bytes and can thus be integrated with traditional
two-dimensional barcodes that are printed on physical cards using legacy
printing processes. This adds tamper resistance to the barcode while
optionally enhancing the barcode to provide information related to whether or
not the physical document has been revoked or suspended by the <a>issuer</a>.
      </p>

      <section>
        <h3>Driver's License Example</h3>

        <p>
This section provides an example on how the technology in this specification
can be utilized to secure the optical barcode on a driver's license that
uses a PDF417 barcode. We start off with an example driver's license:
        </p>

        <figure id="dl-front">
          <img style="margin: auto; display: block; border-radius:15px; width: 50%;"
               src="diagrams/dl-front.png"
               alt="Picture of the front of a driver's license issued by the state of Utopia which contains a picture of the individual that is the subject of the driver's license along with their attributes, such as name, address, height, weight, eye color, and driving privileges.">
          <figcaption style="text-align: center;">
The front of a driver's license issued by the state of Utopia.
          </figcaption>
        </figure>

        <p>
The back of the driver's license contains a PDF417 barcode:
        </p>

        <figure id="dl-back">
          <img style="margin: auto; display: block; border-radius:15px; width: 50%;"
               src="diagrams/dl-back.png"
               alt="Picture of the back of a driver's license issued by the state of Utopia, containing usage rules as well as a PDF417 barcode that encodes much of the information displayed on the front of the card.">
          <figcaption style="text-align: center;">
A back of a driver's license issued by the state of Utopia.
          </figcaption>
        </figure>

        <p>
The PDF417 data contains information that is secured using the algorithms
described in this specification. Namely, the PDF417 barcode contains a
<a>verifiable credential</a> of the following form.
        </p>

        <pre class="example nohighlight"
             title="Verifiable Credential embedded in the PDF417 barcode">
{
  "@context": [
    "https://www.w3.org/ns/credentials/v2",
    "https://w3id.org/vdl/v2",
    "https://w3id.org/vdl/utopia/v1"
  ],
  "type": [
    "VerifiableCredential",
    "OpticalBarcodeCredential"
  ],
  <span class="comment">// the issuer value below is defined as a URL in the 'utopia/v1' context above</span>
  "issuer": "did:web:dmv.utopia.example",
  "credentialStatus": {
    "type": "TerseBitstringStatusListEntry",
    "terseStatusListBaseUrl": "dmv.utopia.gov/statuses/12345/status-lists"
    "terseStatusListIndex": 123567890
  },
  "credentialSubject": {
    "type": "UsDriversLicenseWithMandatoryFieldsPdf417Barcode",
    "signatureBitfield": "uP_BA"
  },
  "proof": {
    "type": "DataIntegrity",
    "cryptosuite": "ecdsa-xi-2023",
    <span class="comment">// the public key below is defined as a URL in the 'utopia/v1' context above</span>
    "verificationMethod": "did:web:dmv.utopia.example#key-1",
    "proofPurpose": "assertionMethod",
    "proofValue": "z4peo48uwK2EF4Fta8P...HzQMDYJ34r9gL"
  }
}
        </pre>

        <p>
The <a>verifiable credential</a> above is then compressed using [[CBOR-LD]]
to the following output (in CBOR Diagnostic Notation):
        </p>

        <pre class="example nohighlight"
             title="CBOR-LD compressed Verifiable Credential (145 bytes)">
1281{
  1 => [ 32768, 32769, 32770],                           <span class="comment">// @context</span>
  155 => [ 116, 164 ],                                   <span class="comment">// type</span>
  192 => 174,                                            <span class="comment">// issuer</span>
  186 => { 154 => 166, 206 => 178, 208 => 1234567890 },  <span class="comment">// credentialStatus</span>
  188 => { 154 => 172, 180 => h'753FF040 },              <span class="comment">// credentialSubject</span>
  194 => {                                               <span class="comment">// proof</span>
    154 => 108,                                          <span class="comment">// type</span>
    214 => 4,                                            <span class="comment">// cryptosuite</span>
    224 => 230                                           <span class="comment">// verificationMethod</span>
    228 => 176,                                          <span class="comment">// proofPurpose</span>
    210 => Uint8Array(65) [ ... ],                       <span class="comment">// proofValue</span>
  }
}
        </pre>

      </section>

      <section>
        <h3>Employment Authorization Example</h3>

        <p>
This section provides an example on how the technology in this specification
can be utilized to secure the machine-readable zone on an employment
authorization document that uses a machine-readable zone (MRZ) on the back of
the card. We start off with an example employment authorization document:
        </p>

        <figure id="ead-front">
          <img style="margin: auto; display: block; border-radius:15px; width: 50%;"
               src="diagrams/ead-front.png"
               alt="Picture of the front of an employment authorization document issued by the state of Utopia which contains a picture of the individual that is the subject of the document along with their attributes, such as name, address, height, weight, eye color, and employment privileges.">
          <figcaption style="text-align: center;">
The front of an employment authorization document issued by the state of Utopia.
          </figcaption>
        </figure>

        <p>
The back of the employment authorization document contains a machine-readable
zone (MRZ) containing information designed to be read through optical character
recognition:
        </p>

        <figure id="ead-back">
          <img style="margin: auto; display: block; border-radius:15px; width: 50%;"
               src="diagrams/ead-back.png"
               alt="Picture of the back of a employment authorization document issued by the state of Utopia, containing usage rules as well as machine-readable zone data that encodes much of the information displayed on the front of the card.">
          <figcaption style="text-align: center;">
A back of an employment authorization document issued by the state of Utopia.
          </figcaption>
        </figure>

        <p>
The MRZ data contains information that is secured using the algorithms
described in this specification. Namely, the QR Code on the front of the
card contains a <a>verifiable credential</a> of the following form, which secures
the information on the back of the card.
        </p>

        <pre class="example nohighlight"
             title="Verifiable Credential expressed as a QR Code on the front of the card">
{
  "@context": [
    "https://www.w3.org/ns/credentials/v2",
    "https://w3id.org/citizenship/v2",
    "https://w3id.org/citizenship/utopia/v1"
  ],
  "type": [
    "VerifiableCredential",
    "OpticalBarcodeCredential"
  ],
  <span class="comment">// the value below is defined as a URL in the 'utopia/v1' context above</span>
  "issuer": "did:web:immigration.utopia.example",
  "credentialSubject": {
    "type": "CompleteMrzBarcode",
  },
  "proof": {
    "type": "DataIntegrity",
    "cryptosuite": "ecdsa-xi-2023",
    <span class="comment">// the value below is defined as a URL in the 'utopia/v1' context above</span>
    "verificationMethod": "did:web:immigration.utopia.example#key-4"
    "proofPurpose": "assertionMethod",
    "proofValue": "z4peo48uwK2EF4Fta8P...HzQMDYJ34r9gL"
  }
}
        </pre>

        <p class="note" title="credentialStatus is optional">
Readers might note that the credential above does not contain the optional
`credentialStatus` property. Not every optical barcode credential issuer will
have the requirement to have revocable optical barcode credentials.
        </p>

        <p>
The <a>verifiable credential</a> above is then compressed using [[CBOR-LD]]
to the following output (in CBOR Diagnostic Notation):
        </p>

        <pre class="example nohighlight"
             title="CBOR-LD compressed Verifiable Credential (120 bytes)">
{
  1 => [ 32768, 32769, 32770],           <span class="comment">// @context</span>
  155 => [ 116, 176 ],                   <span class="comment">// type</span>
  208 => 194,                          <span class="comment">// issuer</span>
  204 => { 154 => 192 },                 <span class="comment">// credentialSubject</span>
  210 => {                               <span class="comment">// proof</span>
    154 => 108,                          <span class="comment">// type</span>
    226 => 4,                        <span class="comment">// cryptosuite</span>
    236 => 242                         <span class="comment">// verificationMethod</span>
    240 => 196,                          <span class="comment">// proofPurpose</span>
    210 => Uint8Array(65) [ ... ],       <span class="comment">// proofValue</span>
  }
}
        </pre>

      </section>

      <section id="terminology">
        <h3>Terminology</h3>

        <div data-include="https://w3c.github.io/vc-data-model/terms.html"></div>

      </section>

      <section id="terms-reference">
        <h3>Terms defined by cited specifications</h3>
        <dl data-sort="ascending">
          <dt><dfn data-cite="XPATH-FUNCTIONS#codepoint-collation" data-lt="code point order|code point ordered|unicode codepoint collation">Unicode code point order</dfn></dt>
          <dd>This refers to determining the order of two Unicode strings (`A` and `B`),
            using <a>Unicode Codepoint Collation</a>,
            as defined in [[XPATH-FUNCTIONS]],
            which defines a
            <a href="https://en.wikipedia.org/wiki/Total_order">total ordering</a>
            of <a>strings</a> comparing code points.
            Note that for UTF-8 encoded strings, comparing the byte sequences gives the same result as <a>code point order</a>.
          </dd>
        </dl>
      </section>

      <section id="conformance">
        <p>
A <dfn>conforming document</dfn> is any concrete expression of the data model
that complies with the normative statements in this specification. Specifically,
all relevant normative statements in Sections
<a href="#data-model"></a> and <a href="#algorithms"></a>
of this document MUST be enforced.
        </p>

        <p>
A <dfn class="lint-ignore">conforming processor</dfn> is any algorithm realized
as software and/or hardware that generates or consumes a
<a>conforming document</a>. Conforming processors MUST produce errors when
non-conforming documents are consumed.
        </p>

      	<p>
This document contains examples of JSON and JSON-LD data. Some of these examples
are invalid JSON, as they include features such as inline comments (`//`)
explaining certain portions and ellipses (`...`) indicating the omission of
information that is irrelevant to the example. Such parts need to be
removed if implementers want to treat the examples as valid JSON or JSON-LD.
        </p>
      </section>

    </section>

    <section>
      <h2>Data Model</h2>

      <p>
The following sections outline the data model that is used by this specification
to express [=verifiable credentials=] that secure optically printed information
such as barcodes and machine-readable zones on travel documents.
      </p>

      <section>
        <h3>OpticalBarcodeCredential</h3>

        <p>
An `OpticalBarcodeCredential` is used to secure the contents of an optical
barcode in a way that provides 1) authorship information , 2) tamper
resistance, and 3) optionally, revocation and suspension status. In other words,
the credential can tell you who issued the optical barcode, if the
optical barcode has been tampered with since it was first issued, and
whether or not the <a>issuer</a> of the optical barcode still warrants that
the document is still valid or not. These features provide significant
anti-fraud protections for physical documents.
        </p>

        <p>
The `credentialSubject` of an `OpticalBarcodeCredential` is either of type
`UsDriversLicenseWithMandatoryFieldsPdf417Barcode` or a `CompleteMrzBarcode`. A 
`UsDriversLicenseWithMandatoryFieldsPdf417Barcode` signifies that
the <a>verifiable credential</a> secures the PDF417 barcode on the physical
document as well as the information expressed in the
<a>verifiable credential</a>. A `CompleteMrzBarcode` signifies that
the <a>verifiable credential</a> secures the machine-readable zone on the
physical document as well as the information expressed in the
<a>verifiable credential</a>.
        </p>

        <p>
If an `OpticalBarcodeCredential` is of type `UsDriversLicenseWithMandatoryFieldsPdf417Barcode`,
there is a REQUIRED additional field `signatureBitfield` that contains information about which fields
in the PDF417 are digitally signed. `signatureBitfield` MUST be a three byte/24 bit value that is 
multibase-base64url encoded for a total of 5 characters in the JSON-LD credential. There are 22
mandatory fields in an AAMVA compliant driver's license PDF417 [[aamva-dl-id-card-design-standard]],
and the first 22 bits of the `signatureBitfield` value correspond to these fields. Each AAMVA mandatory
field begins with a three character element ID (e.g. `DBA` for document expiration date). To construct 
a mapping between bits in the `signatureBitfield` value and these fields, sort these element IDs lexically.
Then, if a bit in position `i` of `signatureBitfield` is `1`, then the AAMVA mandatory field in
position `i` of the sorted element IDs is digitally signed. The last two bits in `signatureBitfield`
MUST be `0`. For more information, see 
<a href="#create-opticaldatahash">Section 3.5.4</a>.
        </p>

        <p>
In order to achieve as much compression as possible, it is RECOMMENDED that the
`issuer` and `verificationMethod` fields utilize terms from a JSON-LD Context,
which can then be compressed down to a few bytes due to CBOR-LD's semantic
compression mechanism.
        </p>

        <p>
An example of an optical barcode credential that utilizes the properties
specified in this section is provided below:
        </p>

        <pre class="example nohighlight"
             title="An OpticalBarcodeCredential utilizing a TerseBitstringStatusListEntry">
{
  "@context": [
    "https://www.w3.org/ns/credentials/v2",
    "https://w3id.org/vdl/v2",
    "https://w3id.org/vdl/utopia/v1"
  ],
  "type": [
    "VerifiableCredential",
    <span class="highlight">"OpticalBarcodeCredential"</span>
  ],
  "issuer": "did:web:dmv.utopia.example",
  "credentialStatus": <span class="highlight">{
    "type": "TerseBitstringStatusListEntry",
    "terseStatusListBaseUrl": "dmv.utopia.gov/statuses/12345/status-lists"
    "terseStatusListIndex": 123567890
  }</span>,
  "credentialSubject": {
    <span class="highlight">"type": "UsDriversLicenseWithMandatoryFieldsPdf417Barcode"</span>,
    <span class="highlight">"signatureBitfield": "uP_BA"</span>
  }
}
        </pre>
      </section>

      <section>
        <h3>TerseBitstringStatusListEntry</h3>

        <p>
A `TerseBitstringStatusListEntry` is a compact representation
of a `BitstringStatusListEntry` as defined in the [[[VC-BITSTRING-STATUS-LIST]]] 
specification.
        </p>

        <p>
An object of type `TerseBitstringStatusListEntry` MUST have two additional properties:
          <ul>
            <li>
`terseStatusListBaseUrl`, which identifies the location of the status lists associated with this credential,
            </li>
            <li>
`terseStatusListIndex`, which specifies an individual status at the above URL.
            </li>
          </ul>
        </p>
To process a `TerseBitstringStatusListEntry`, apply the algorithm in 
<a href="#convert-status-list-entries">Section 3.4</a> to convert it to a `BitstringStatusListEntry`,
then process it as in [[[VC-BITSTRING-STATUS-LIST]]].
    
      </section>

    </section>

    <section>
      <h2>Algorithms</h2>

      <p>
The following section describes algorithms for adding and verifying digital
proofs that protect optical information, such as barcodes and machine-readable
zones, on physical media, such as driver's licenses and travel documents.
      </p>

      <p>
Generally speaking, the algorithms in this section are effectively the same
as the ones in the [[[VC-DI-ECDSA]]] [[VC-DI-ECDSA]] except that the
algorithm name is different because the cryptographic hashing process includes
the machine-readable barcode information when calculating the digital signature
such that the optical barcode is protected.
      </p>

      <section>
        <h3>CBOR-LD Compression</h3>

        <p>
This specification requires that an application-specific compression table is
provided to a CBOR-LD processor when encoding and decoding
<a>verifiable credentials</a> of type `OpticalBarcodeCredential`. A registry for
all context URLs for various issuers is <a href="cbor-ld-compression-table.csv">
provided as a comma-separated value file</a> and can be updated and modified via
<a href="https://github.com/digitalbazaar/verifiable-barcodes/pulls/">
change requests</a> to the file on an append-only and first-come-first-served
basis. Implementations SHOULD retrieve and utilize the latest file on a monthly
basis to ensure that compression and decompression supports the latest values.
        </p>

      </section>

      <section>
        <h3>Credential Creation</h3>

        <ol class="algorithm">
          <li>
Set |opticalData| to the data in the optical barcode to be secured.
          </li>
          <li>
Set |statusListEntryVerbose| to the `BitstringStatusListCredential`
(as defined in the [[[VC-BITSTRING-STATUS-LIST]]] specification) that the issuer
wishes to add to the `OpticalBarcodeCredential`.
          </li>
          <li>
Let |statusListEntryTerse| be an empty [=map=]. Set |statusListEntryTerse|.|type| to `TerseBitstringStatusListEntry` and |statusListEntryTerse|.|index| to the integer representation of |statusListEntryVerbose|.|statusListIndex|.
          </li>
          <li>
Set |issuerUrl| to the URL the issuer wishes to use for credential verification.
          </li>
          <li>
Set |unsignedStatus| to an `OpticalBarcodeCredential` with
|unsignedStatus|.|issuer| set to |issuerUrl| and |unsignedStatus|.|credentialStatus|
set to |statusListEntryTerse|.
          </li>
          <li>
Set |signedStatusVc| to the result of using the algorithm in
<a href="#add-proof-ecdsa-xi-2023">Section 3.2.1</a> to sign |opticalData|
and |unsignedStatus|.
          </li>
          <li>
Encode |signedStatusVc| using CBOR-LD [[CBOR-LD]] and add it to the designated area of the |opticalData|.
          </li>
          <li>
Generate the machine-readable credential (MRZ or PDF417).
          </li>
        </ol>
      </section>

      <section>
        <h3>Credential Validation</h3>

        <ol class="algorithm">
          <li>
Set |securedDocument| to the data in the PDF417 or MRZ.
          </li>
          <li>
Set |verificationResult| to the result of applying the algorithm in
<a href="#verify-proof-ecdsa-xi-2023">Section 3.2.2</a> to |securedDocument|.
          </li>
          <li>
Set |credential| to the `OpticalBarcodeCredential` in |securedDocument|.
          </li>
          <li>
Set |statusListEntry| to the result of applying the algorithm in
<a href="#convert-status-list-entries">Section 3.4</a> to |credential|.
          </li>
          <li>
Set |statusResult| to the result of applying the algorithm in
<a data-cite="VC-BITSTRING-STATUS-LIST#validate-algorithm">Bitstring Status List v1.0: Validate Algorithm</a> to |statusListEntry|.
          </li>
          <li>
Return (|validationResult|, |statusResult|).
          </li>
        </ol>
      </section>

      <section>
        <h3>Convert Status List Entries</h3>

        <p>
The algorithm in this section is used to convert the
`TerseBitstringStatusListEntry` to a `BitstringStatusListEntry`, which is used
after verification has been performed on the <a>verifiable credential</a>,
during the validation process.
        </p>

        <p>
After <a>verifiable credential</a> verification has been performed, the
algorithm takes an `OpticalBarcodeCredential` <a>verifiable credential</a>
([=struct=] |vc|) as input and returns a status object ([=map=] |result|) that
contains a [=boolean=] |status| [=map/entry=] and a [=list=] |statusListEntry|
of one or more [=struct=] values representing `BitstringStatusListEntry`
objects.
        </p>

        <ol class="algorithm">
          <li>
Set |result| to be an empty [=map=] and initialize the |result|.|status| value
to `false`.
          </li>
          <li>
Set |year| and |month| to the respective values specified in the
|vc|.|proof|.|created| field.
          </li>
          <li>
Set |didDocument| to be the result of dereferencing |issuer|. If the dereference
does not result in a conforming DID Document, raise an
<a data-cite="VC-DATA-INTEGRITY#INVALID_CONTROLLER_DOCUMENT">
INVALID_CONTROLLER_DOCUMENT</a> error.
          </li>
          <li>
For each |service| value in |didDocument| where the |service|.|type| is
`BitstringStatusListService`:
            <ol class="algorithm">
              <li>
Initialize |bslEntry| to an empty [=map=].
              </li>
              <li>
Set |bslEntry|.|type| to `BitstringStatusListEntry`.
              </li>
              <li>
Set |bslEntry|.|statusPurpose| to |service|.|statusPurpose|.
              </li>
              <li>
Set |bslEntry|.|statusListIndex| to |vc|.|credentialStatus|.|index|, ensuring
that the value is converted to a string.
              </li>
              <li>
Set |bslEntry|.|statusListCredential| to |service|.|serviceEndpoint|,
replacing any `{{YYYY}}` text with a four-character representation of |year|
and any `{{MM}}` text with a two-character representation of |month|, using
leading zeros as necessary.
              </li>
              <li>
Add |bslEntry| to |result|.|statusListEntry|.
              </li>
              <li>
Set |result|.|status| to `true`.
              </li>
            </ol>
          </li>
          <li>
Return |result|.
          </li>
        </ol>

        <p>
Each value in |result|.|statusList| can be used as input to the
<a data-cite="VC-BITSTRING-STATUS-LIST#validate-algorithm">
validation algorithm</a> in the [[[VC-BITSTRING-STATUS-LIST]]] specification.
        </p>

        <p class="note" title="Status lists are optional">
Implementers are advised that not all <a>issuers</a> will publish status
list information for their <a>verifiable credentials</a>. Some <a>issuers</a>
might require authorization before allowing a <a>verifier</a> to access a
status list credential.
        </p>

      </section>

      <section>
        <h3>ecdsa-xi-2023</h3>

        <p>
The `ecdsa-xi-2023` is effectively the `ecdsa-rdfc-2019` algorithm
[[VC-DI-ECDSA]] with an added step that takes some "extra information" (xi) as
input, such as the original optical barcode data, and includes that data in the
information that is protected by the digital signature. The algorithms in this
section detail how such a signature is created and verified.
        </p>

        <section>
          <h4>Add Proof (ecdsa-xi-2023)</h4>

          <p>
To generate a proof, the algorithm in
<a href="https://www.w3.org/TR/vc-data-integrity/#add-proof">
Section 4.1: Add Proof</a> in the Data Integrity
[[VC-DATA-INTEGRITY]] specification MUST be executed.
For that algorithm, the cryptographic suite specific
<a href="https://www.w3.org/TR/vc-data-integrity/#dfn-transformation-algorithm">
transformation algorithm</a> is defined in the
<a href="https://www.w3.org/TR/vc-di-ecdsa/#transformation-ecdsa-rdfc-2019">
Transformation (ecdsa-rdfc-2019)</a> section of the [[[VC-DI-ECDSA]]], the
<a href="https://www.w3.org/TR/vc-data-integrity/#dfn-hashing-algorithm">
hashing algorithm</a> is defined in Section
<a href="#hashing-ecdsa-xi-2023"></a>, and the
<a href="https://www.w3.org/TR/vc-data-integrity/#dfn-proof-serialization-algorithm">
proof serialization algorithm</a> is defined in the
<a href="https://www.w3.org/TR/vc-di-ecdsa/#proof-serialization-ecdsa-rdfc-2019">
Proof Serialization (ecdsa-rdfc-2019)</a> section of the [[[VC-DI-ECDSA]]].
          </p>
        </section>

        <section>
          <h4>Verify Proof (ecdsa-xi-2023)</h4>

          <p>
To verify a proof, the algorithm in
<a href="https://www.w3.org/TR/vc-data-integrity/#verify-proof">
Section 4.2: Verify Proof</a> in the Data Integrity [[VC-DATA-INTEGRITY]]
specification MUST be executed. For that algorithm, the cryptographic suite
specific
<a href="https://www.w3.org/TR/vc-data-integrity/#dfn-transformation-algorithm">
transformation algorithm</a> is defined in the
<a href="https://www.w3.org/TR/vc-di-ecdsa/#transformation-ecdsa-rdfc-2019">
Transformation (ecdsa-rdfc-2019)</a> section of the [[[VC-DI-ECDSA]]], the
<a href="https://www.w3.org/TR/vc-data-integrity/#dfn-hashing-algorithm">
hashing algorithm</a> is defined in
Section <a href="#hashing-ecdsa-xi-2023"></a>, and the
<a href="https://www.w3.org/TR/vc-data-integrity/#dfn-proof-serialization-algorithm">
proof verification algorithm</a> is defined in the
<a href="https://www.w3.org/TR/vc-di-ecdsa/#proof-verification-ecdsa-rdfc-2019">
Proof Verification (ecdsa-rdfc-2019)</a> section of the [[[VC-DI-ECDSA]]].
          </p>
        </section>

        <section>
          <h4>Hashing (ecdsa-xi-2023)</h4>

          <p>
The hashing algorithm is what is defined in the
<a href="https://www.w3.org/TR/vc-di-ecdsa/#hashing-ecdsa-rdfc-2019">
Hashing (ecdsa-rdfc-2019)</a> section of the [[[VC-DI-ECDSA]]] specification
with the addition of the hashing of the optical data, as described below. It is
presumed that the implementation makes the machine-readable optical data (PDF417
or MRZ data) available to this hashing algorithm.
          </p>

          <p>
The required inputs to this algorithm are a <em>transformed data document</em>
(<var>transformedDocument</var>), a <em>canonical proof configuration</em>
(<var>canonicalProofConfig</var>), and the <em>optical data</em>
(<var>opticalDataBytes</var>). A single <em>hash data</em> value represented as
series of bytes is produced as output.
          </p>

          <p>
The hashing algorithm is what is defined in the
<a href="https://www.w3.org/TR/vc-di-ecdsa/#hashing-ecdsa-rdfc-2019">
Hashing (ecdsa-rdfc-2019)</a> section of the [[[VC-DI-ECDSA]]] with step 3
replaced with the following two steps:
          </p>

          <ol class="algorithm">
            <li>
Let <var>opticalDataHash</var> be the result of applying the same hash algorithm
that was applied to <var>hashData</var> to the <var>opticalDataBytes</var>
value.
            </li>
            <li>
Let <var>hashData</var> be the result of joining <var>proofConfigHash</var> (the
first hash), <var>transformedDocumentHash</var> (the second hash), and
<var>opticalDataHash</var> (the third hash).
            </li>
          </ol>

        </section>

        <section>
          <h4> Create opticalDataHash</h4>
        
          <section>
            <h5>`UsDriversLicenseWithMandatoryFieldsPdf417Barcode` Credentials</h5>
            <ol class="algorithm">
              <li>
Set |dataToCanonicalize| to an empty array.
              </li>
              <li>
Set |bitfieldDecoded| to be first 22 bits of the length 24 bitstring resulting from decoding `credentialSubject.signatureBitfield`
from multibase-base64url to binary.
              </li>
              <li>
Set |fieldsAlphabetized| to be an array containing the 22 AAMVA mandatory PDF417 Element IDs 
[[aamva-dl-id-card-design-standard]] sorted in Unicode code point order (i.e. ['DAC', 'DAD' ... 'DDG']).
              </li>
              <li>
For each bit with value `1` in |bitfieldDecoded|:
                <ol class="algorithm">
                  <li>
Set the string |fieldName| to |fieldsAlphabetized|[|i|], where |i| is the index of the bit in |bitfieldDecoded|.
                  </li>
                  <li>
Set the string |fieldData| to the data that will be in the PDF417 associated with that field name.
                  </li>
                  <li>
Concatenate |fieldData| to the end of |fieldName|, and append the result to |dataToCanonicalize|.
                  </li>
                </ol>
              </li>
              <li>
Set |canonicalizedData| to the result of sorting |dataToCanonicalize| in Unicode code point order and then applying a join operation
to create a single string from the array.
              </li>
              <li>
Hash |canonicalizedData| and return the result.
              </li>
            </ol>
          </section>

          <section>
            <h5>`CompleteMrzBarcode` Credentials</h5>
            <ol class="algorithm">
              <li>
Set |dataToCanonicalize| to an empty array.
              </li>
              <li>
For each line in the Machine Readable Zone on the credential:
                <ol class="algorithm">
                  <li>
Set |mrzLine| to a string containing the data in that line.
                  </li>
                  <li>
Append a newline character to the end of |mrzLine| and append |mrzLine| to |dataToCanonicalize|.
                  </li>
                </ol>
              </li>
              <li>
Set |canonicalizedData| to the result of ordering the elements of |dataToCanonicalize| to match the order they appear
on the credential and then applying a join operation to create a single string from the array.
              </li>
              <li>
Hash |canonicalizedData| and return the result.
              </li>
            </ol>
          </section>
        </section>
        <section>
          <h4>Proof Configuration (ecdsa-xi-2023)</h4>

          <p>
The proof configuration algorithm is what is defined in the
<a href="https://www.w3.org/TR/vc-di-ecdsa/#proof-configuration-ecdsa-rdfc-2019">
Proof Configuration (ecdsa-rdfc-2019)</a> section of the [[[VC-DI-ECDSA]]] with
step 4 replaced with the following step:
          </p>

          <ol class="algorithm">
            <li>
If <var>options</var>.<var>type</var> is not set to `DataIntegrityProof` and
<var>proofConfig</var>.<var>cryptosuite</var> is not set to `ecdsa-xi-2023`, an
`INVALID_PROOF_CONFIGURATION` error MUST be raised.
            </li>
          </ol>

        </section>

      </section>

    </section>






    <section class="informative">
      <h2>Security Considerations</h2>

      <p class="advisement">
Before reading this section, readers are urged to familiarize themselves
with general security advice provided in the
<a href="https://www.w3.org/TR/vc-data-integrity/#security-considerations">
Security Considerations section of the Data Integrity specification</a> as
well as the specific security advice provided in the
<a href="https://www.w3.org/TR/vc-di-ecdsa/#security-considerations">
Security Considerations section of the ECDSA Cryptosuites specification</a>.
      </p>

      <p>
In the following sections, we review these important points and direct
the reader to additional information.
      </p>

      <p class="issue">
Add security considerations specific to this specification.
      </p>

    </section>

    <section>
      <h2>Privacy Considerations</h2>

      <p class="advisement">
Before reading this section, readers are urged to familiarize themselves
with general security advice provided in the
<a href="https://www.w3.org/TR/vc-data-integrity/#privacy-considerations">
Security Considerations section of the Data Integrity specification</a> as
well as the specific security advice provided in the
<a href="https://www.w3.org/TR/vc-di-ecdsa/#privacy-considerations">
Security Considerations section of the ECDSA Cryptosuites specification</a>.
      </p>

      <p>
The following section describes privacy considerations that developers
implementing this specification should be aware of in order to avoid violating
privacy assumptions.
      </p>

      <p class="issue">
Add security considerations specific to this specification.
      </p>

    </section>

    <section class="informative">
      <h2>Revision History</h2>

      <p>
This section contains the substantive changes that have been made to this
specification over time.
      </p>

      <p class="issue" title="Content will be filled in after standards-track has been started">
The content for this specification will be filled in after the
standards-track process has been started.
      </p>

    </section>

  </body>
</html>
